import { IntelligenceAvailableStatusType, AutoChapterStatusesType } from '@loomhq/sdk-store/src/post-recording/types';

declare enum SDKUnsupportedReasons {
    IncompatibleBrowser = "incompatible-browser",
    ThirdPartyCookiesDisabled = "third-party-cookies-disabled",
    NoMediaStreamsSupport = "no-media-streams-support"
}

declare enum Environment {
    Development = "development",
    Testbench = "testbench",
    Staging = "staging",
    Production = "production"
}
declare enum RecordingType {
    ScreenAndCamera = "screen_cam",
    ScreenOnly = "screen",
    CameraOnly = "cam"
}
interface SDKStyles {
    /**
     * Font family to be used instead of loom defaults. This is 1:1 with `font-family`.
     */
    fontFamily: string;
    /**
     * Base font unit size used to calculate the font size for the text.
     */
    fontUnitSize: string;
    /**
     * Collection of record button color options
     */
    recordButtonColor: string;
    recordButtonHoverColor: string;
    recordButtonActiveColor: string;
    /**
     * Collection of primary color overrides
     */
    primaryColor: string;
    primaryHoverColor: string;
    primaryActiveColor: string;
}
interface WholeConfig {
    allowedRecordingTypes: [RecordingType, ...RecordingType[]];
    bubbleResizable: boolean;
    /**
     * The default selection for recording type. If `allowedRecordingTypes` is specified, should
     * include this default type in the list. If unspecified, defaults to Screen and Camera
     */
    defaultRecordingType: RecordingType;
    disablePreviewModal: boolean;
    /**
     * Explicitly turns on the new UI for ALL users (including signed out users).
     */
    enableNewUi: boolean;
    enableOnboardingTutorial: boolean;
    enablePictureInPicture: boolean;
    insertButtonText: string;
    /**
     * From which product the SDK is firing from (ex: Confluence, Jira)
     */
    productName?: string;
    /**
     * The entrypoint within the product from which the SDK fires
     */
    entryPointName?: string;
    /**
     * Collection of styles that can be applied to the loom components.
     */
    styles: Partial<SDKStyles>;
}
type SDKConfig = Partial<WholeConfig>;
declare enum SDKState {
    Closed = "closed",
    PreRecording = "pre-recording",
    ActiveRecording = "active-recording",
    PostRecording = "post-recording"
}
interface LoomVideo {
    id: string;
    title: string;
    height: number;
    width: number;
    sharedUrl: string;
    embedUrl: string;
    thumbnailHeight?: number;
    thumbnailWidth?: number;
    thumbnailUrl?: string;
    duration?: number;
    providerUrl: string;
    autoTitleStatus?: IntelligenceAvailableStatusType;
    autoDescriptionStatus?: IntelligenceAvailableStatusType;
    description?: string;
    autoChaptersStatus?: AutoChapterStatusesType;
    autoChaptersCount?: number;
}
/**
 * Types pull eventemitter3 to avoid bundling types from that package.
 */
type ValidEventTypes = string | symbol | any;
type EventNames<T extends ValidEventTypes> = T extends string | symbol ? T : keyof T;
type ArgumentMap<T> = {
    [K in keyof T]: T[K] extends (...args: any[]) => void ? Parameters<T[K]> : T[K] extends any[] ? T[K] : any[];
};
type EventListener<T extends ValidEventTypes, K extends EventNames<T>> = T extends string | symbol ? (...args: any[]) => void : (...args: ArgumentMap<Exclude<T, string | symbol>>[Extract<K, keyof T>]) => void;
type EventArgs<T extends ValidEventTypes, K extends EventNames<T>> = Parameters<EventListener<T, K>>;
interface EventEmitter<EventTypes extends ValidEventTypes = string | symbol, Context = any> {
    eventNames(): Array<EventNames<EventTypes>>;
    listeners<T extends EventNames<EventTypes>>(event: T): Array<EventListener<EventTypes, T>>;
    listenerCount(event: EventNames<EventTypes>): number;
    emit<T extends EventNames<EventTypes>>(event: T, ...args: EventArgs<EventTypes, T>): boolean;
    on<T extends EventNames<EventTypes>>(event: T, fn: EventListener<EventTypes, T>, context?: Context): this;
    addListener<T extends EventNames<EventTypes>>(event: T, fn: EventListener<EventTypes, T>, context?: Context): this;
    once<T extends EventNames<EventTypes>>(event: T, fn: EventListener<EventTypes, T>, context?: Context): this;
    removeListener<T extends EventNames<EventTypes>>(event: T, fn?: EventListener<EventTypes, T>, context?: Context, once?: boolean): this;
    off<T extends EventNames<EventTypes>>(event: T, fn?: EventListener<EventTypes, T>, context?: Context, once?: boolean): this;
    removeAllListeners(event?: EventNames<EventTypes>): this;
}

type HookFn<T> = (a: T) => void;
interface Hooks {
    onInsertClicked: HookFn<LoomVideo>;
    onStart?: HookFn<void>;
    onRecordingStarted?: HookFn<void>;
    onCancel?: HookFn<void>;
    onComplete?: HookFn<void>;
    onAnalyticsEvent?: HookFn<string>;
    onLifecycleUpdate?: HookFn<SDKState>;
    onRecordingComplete: HookFn<LoomVideo>;
    onUploadComplete: HookFn<LoomVideo>;
}//# sourceMappingURL=hooks.d.ts.map

interface Position {
    x: number;
    y: number;
}
interface ButtonEmitterEvents {
    'bubble-drag-end': (pos: Position) => void;
    'bubble-drag-start': (pos: Position) => void;
    'bubble-move': (pos: Position) => void;
    cancel: () => void;
    complete: () => void;
    'insert-click': (video: LoomVideo) => void;
    'lifecycle-update': (state: SDKState) => void;
    'recording-complete': (video: LoomVideo) => void;
    'recording-start': () => void;
    start: () => void;
    'upload-complete': (video: LoomVideo) => void;
}
/**
 * Public definition for the SDK Button.
 */
interface SDKButtonInterface extends EventEmitter<ButtonEmitterEvents> {
    /**
     * Opens the recording panel to start a user's record flow.
     */
    openPreRecordPanel: () => void;
    /**
     * Closes the recording panel.
     */
    closePreRecordPanel: () => void;
    /**
     * Move the recording bubble.
     * @param pos New position where the bubble will be moved to. This value is pixels relative
     * to the bubble's iframe container.
     */
    moveBubble: (p: Position) => void;
    /**
     * End a recording in progress
     */
    endRecording: () => void;
}

interface StandardSDK {
    mode: 'standard';
    publicAppId: string;
    environment?: Environment;
    config?: SDKConfig;
}
interface CustomSDK {
    mode: 'custom';
    jws: string;
    environment?: Environment;
    config?: SDKConfig;
}
interface FirstPartyMode {
    config?: SDKConfig;
    environment?: Environment;
    jws: string;
    mode: 'first-party';
    publicAppId: string;
    siteId: string;
}
type ButtonFn = (a?: {
    element?: HTMLElement;
    hooks?: Hooks;
}) => SDKButtonInterface;
type SDKResult = {
    teardown: () => void;
    configureButton: ButtonFn;
    updateConfig: ({ config }: {
        config: SDKConfig;
    }) => void;
    status: () => {
        state: SDKState | undefined;
        success: boolean;
    };
};
type SetupArgs = StandardSDK | CustomSDK | FirstPartyMode;
type SetupFunction = (a: SetupArgs) => Promise<SDKResult>;

interface LegacySetupArgs {
    publicAppId?: string;
    jws?: string;
    environment?: Environment;
    config?: SDKConfig;
}
type LegacySetup = (a: LegacySetupArgs) => Promise<SDKResult>;
declare const setup: LegacySetup;
declare const createInstance: SetupFunction;

export { Environment, Hooks, LegacySetup, LegacySetupArgs, LoomVideo, RecordingType, SDKButtonInterface, SDKConfig, SDKResult, SDKState, SDKUnsupportedReasons, SetupArgs, SetupFunction, createInstance, setup };
